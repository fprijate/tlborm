<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ook! - The Little Book of Rust Macros</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="mbe-README.html"><strong aria-hidden="true">1.</strong> Macros, A Methodical Introduction</a></li><li><ol class="section"><li class="expanded "><a href="mbe-syn-README.html"><strong aria-hidden="true">1.1.</strong> Syntax Extensions</a></li><li><ol class="section"><li class="expanded "><a href="mbe-syn-source-analysis.html"><strong aria-hidden="true">1.1.1.</strong> Source Analysis</a></li><li class="expanded "><a href="mbe-syn-macros-in-the-ast.html"><strong aria-hidden="true">1.1.2.</strong> Macros in the AST</a></li><li class="expanded "><a href="mbe-syn-expansion.html"><strong aria-hidden="true">1.1.3.</strong> Expansion</a></li></ol></li><li class="expanded "><a href="mbe-macro-rules.html"><strong aria-hidden="true">1.2.</strong> macro_rules!</a></li><li class="expanded "><a href="mbe-min-README.html"><strong aria-hidden="true">1.3.</strong> Minutiae</a></li><li><ol class="section"><li class="expanded "><a href="mbe-min-captures-and-expansion-redux.html"><strong aria-hidden="true">1.3.1.</strong> Captures and Expansion Redux</a></li><li class="expanded "><a href="mbe-min-hygiene.html"><strong aria-hidden="true">1.3.2.</strong> Hygiene</a></li><li class="expanded "><a href="mbe-min-non-identifier-identifiers.html"><strong aria-hidden="true">1.3.3.</strong> Non-Identifier Identifiers</a></li><li class="expanded "><a href="mbe-min-debugging.html"><strong aria-hidden="true">1.3.4.</strong> Debugging</a></li><li class="expanded "><a href="mbe-min-scoping.html"><strong aria-hidden="true">1.3.5.</strong> Scoping</a></li><li class="expanded "><a href="mbe-min-import-export.html"><strong aria-hidden="true">1.3.6.</strong> Import/Export</a></li></ol></li></ol></li><li class="expanded "><a href="pim-README.html"><strong aria-hidden="true">2.</strong> Macros, A Practical Introduction</a></li><li class="expanded "><a href="pat-README.html"><strong aria-hidden="true">3.</strong> Patterns</a></li><li><ol class="section"><li class="expanded "><a href="pat-callbacks.html"><strong aria-hidden="true">3.1.</strong> Callbacks</a></li><li class="expanded "><a href="pat-incremental-tt-munchers.html"><strong aria-hidden="true">3.2.</strong> Incremental TT Munchers</a></li><li class="expanded "><a href="pat-internal-rules.html"><strong aria-hidden="true">3.3.</strong> Internal Rules</a></li><li class="expanded "><a href="pat-push-down-accumulation.html"><strong aria-hidden="true">3.4.</strong> Push-Down Accumulation</a></li><li class="expanded "><a href="pat-repetition-replacement.html"><strong aria-hidden="true">3.5.</strong> Repetition Replacement</a></li><li class="expanded "><a href="pat-trailing-separators.html"><strong aria-hidden="true">3.6.</strong> Trailing Separators</a></li><li class="expanded "><a href="pat-tt-bundling.html"><strong aria-hidden="true">3.7.</strong> TT Bundling</a></li><li class="expanded "><a href="pat-visibility.html"><strong aria-hidden="true">3.8.</strong> Visibility</a></li><li class="expanded "><a href="pat-provisional.html"><strong aria-hidden="true">3.9.</strong> Provisional</a></li></ol></li><li class="expanded "><a href="blk-README.html"><strong aria-hidden="true">4.</strong> Building Blocks</a></li><li><ol class="section"><li class="expanded "><a href="blk-ast-coercion.html"><strong aria-hidden="true">4.1.</strong> AST Coercion</a></li><li class="expanded "><a href="blk-counting.html"><strong aria-hidden="true">4.2.</strong> Counting</a></li><li class="expanded "><a href="blk-enum-parsing.html"><strong aria-hidden="true">4.3.</strong> Enum Parsing</a></li></ol></li><li class="expanded "><a href="aeg-README.html"><strong aria-hidden="true">5.</strong> Annotated Examples</a></li><li><ol class="section"><li class="expanded "><a href="aeg-ook.html" class="active"><strong aria-hidden="true">5.1.</strong> Ook!</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Little Book of Rust Macros</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#ook" id="ook">Ook!</a></h1>
<p>This macro is an implementation of the <a href="http://www.dangermouse.net/esoteric/ook.html">Ook! esoteric language</a>, which is isomorphic to the <a href="http://www.muppetlabs.com/%7Ebreadbox/bf/">Brainfuck esoteric language</a>.</p>
<p>The execution model for the language is very simple: memory is represented as an array of &quot;cells&quot; (typically at least 8-bits) of some indeterminate number (usually at least 30,000).  There is a pointer into memory which starts off at position 0.  Finally, there is an execution stack (used to implement looping) and pointer into the program, although these last two are not exposed to the running program; they are properties of the runtime itself.</p>
<p>The language itself is comprised of just three tokens: <code>Ook.</code>, <code>Ook?</code>, and <code>Ook!</code>.  These are combined in pairs to form the eight different operations:</p>
<ul>
<li><code>Ook. Ook?</code> - increment pointer.</li>
<li><code>Ook? Ook.</code> - decrement pointer.</li>
<li><code>Ook. Ook.</code> - increment pointed-to memory cell.</li>
<li><code>Ook! Ook!</code> - decrement pointed-to memory cell.</li>
<li><code>Ook! Ook.</code> - write pointed-to memory cell to standard output.</li>
<li><code>Ook. Ook!</code> - read from standard input into pointed-to memory cell.</li>
<li><code>Ook! Ook?</code> - begin a loop.</li>
<li><code>Ook? Ook!</code> - jump back to start of loop if pointed-to memory cell is not zero; otherwise, continue.</li>
</ul>
<p>Ook! is interesting because it is known to be Turing-complete, meaning that any environment in which you can implement it must <em>also</em> be Turing-complete.</p>
<h2><a class="header" href="#implementation" id="implementation">Implementation</a></h2>
<pre><code class="language-ignore">#![recursion_limit = &quot;158&quot;]
</code></pre>
<p>This is, in fact, the lowest possible recursion limit for which the example program provided at the end will actually compile.  If you're wondering what could be so fantastically complex that it would <em>justify</em> a recursion limit nearly five times the default limit... <a href="https://en.wikipedia.org/wiki/Hello_world_program">take a wild guess</a>.</p>
<pre><code class="language-ignore">type CellType = u8;
const MEM_SIZE: usize = 30_000;
</code></pre>
<p>These are here purely to ensure they are visible to the macro expansion.<sup class="footnote-reference"><a href="#*">1</a></sup></p>
<div class="footnote-definition" id="*"><sup class="footnote-definition-label">1</sup>
<p>They <em>could</em> have been defined within the macro, but then they would have to have been explicitly passed around (due to hygiene).  To be honest, by the time I realised I <em>needed</em> to define these, the macro was already mostly written and... well, would <em>you</em> want to go through and fix this thing up if you didn't <em>absolutely need</em> to?</p>
</div>
<pre><code class="language-ignore">macro_rules! Ook {
</code></pre>
<p>The name should <em>probably</em> have been <code>ook!</code> to match the standard naming convention, but the opportunity was simply too good to pass up.</p>
<p>The rules for this macro are broken up into sections using the <a href="../pat/README.html#internal-rules">internal rules</a> pattern.</p>
<p>The first of these will be a <code>@start</code> rule, which takes care of setting up the block in which the rest of our expansion will happen.  There is nothing particularly interesting in this: we define some variables and helper functions, then do the bulk of the expansion.</p>
<p>A few small notes:</p>
<ul>
<li>We are expanding into a function largely so that we can use <code>try!</code> to simplify error handling.</li>
<li>The use of underscore-prefixed names is so that the compiler will not complain about unused functions or variables if, for example, the user writes an Ook! program that does no I/O.</li>
</ul>
<pre><code class="language-ignore">    (@start $($Ooks:tt)*) =&gt; {
        {
            fn ook() -&gt; ::std::io::Result&lt;Vec&lt;CellType&gt;&gt; {
                use ::std::io;
                use ::std::io::prelude::*;
    
                fn _re() -&gt; io::Error {
                    io::Error::new(
                        io::ErrorKind::Other,
                        String::from(&quot;ran out of input&quot;))
                }
                
                fn _inc(a: &amp;mut [u8], i: usize) {
                    let c = &amp;mut a[i];
                    *c = c.wrapping_add(1);
                }
                
                fn _dec(a: &amp;mut [u8], i: usize) {
                    let c = &amp;mut a[i];
                    *c = c.wrapping_sub(1);
                }
    
                let _r = &amp;mut io::stdin();
                let _w = &amp;mut io::stdout();
        
                let mut _a: Vec&lt;CellType&gt; = Vec::with_capacity(MEM_SIZE);
                _a.extend(::std::iter::repeat(0).take(MEM_SIZE));
                let mut _i = 0;
                {
                    let _a = &amp;mut *_a;
                    Ook!(@e (_a, _i, _inc, _dec, _r, _w, _re); ($($Ooks)*));
                }
                Ok(_a)
            }
            ook()
        }
    };
</code></pre>
<h3><a class="header" href="#opcode-parsing" id="opcode-parsing">Opcode parsing</a></h3>
<p>Next are the &quot;execute&quot; rules, which are used to parse opcodes from the input.</p>
<p>The general form of these rules is <code>(@e $syms; ($input))</code>.  As you can see from the <code>@start</code> rule, <code>$syms</code> is the collection of symbols needed to actually implement the program: input, output, the memory array, <em>etc.</em>.  We are using <a href="../pat/README.html#tt-bundling">TT bundling</a> to simplify forwarding of these symbols through later, intermediate rules.</p>
<p>First, is the rule that terminates our recursion: once we have no more input, we stop.</p>
<pre><code class="language-ignore">    (@e $syms:tt; ()) =&gt; {};
</code></pre>
<p>Next, we have a single rule for <em>almost</em> each opcode.  For these, we strip off the opcode, emit the corresponding Rust code, then recurse on the input tail: a textbook <a href="../pat/README.html#incremental-tt-munchers">TT muncher</a>.</p>
<pre><code class="language-ignore">    // Increment pointer.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook. Ook? $($tail:tt)*))
    =&gt; {
        $i = ($i + 1) % MEM_SIZE;
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Decrement pointer.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook? Ook. $($tail:tt)*))
    =&gt; {
        $i = if $i == 0 { MEM_SIZE } else { $i } - 1;
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Increment pointee.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook. Ook. $($tail:tt)*))
    =&gt; {
        $inc($a, $i);
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Decrement pointee.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook! Ook! $($tail:tt)*))
    =&gt; {
        $dec($a, $i);
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Write to stdout.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook! Ook. $($tail:tt)*))
    =&gt; {
        try!($w.write_all(&amp;$a[$i .. $i+1]));
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Read from stdin.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook. Ook! $($tail:tt)*))
    =&gt; {
        try!(
            match $r.read(&amp;mut $a[$i .. $i+1]) {
                Ok(0) =&gt; Err($re()),
                ok @ Ok(..) =&gt; ok,
                err @ Err(..) =&gt; err
            }
        );
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
</code></pre>
<p>Here is where things get more complicated.  This opcode, <code>Ook! Ook?</code>, marks the start of a loop.  Ook! loops are translated to the following Rust code:</p>
<blockquote>
<p><strong>Note</strong>: this is <em>not</em> part of the larger code.</p>
<pre><code class="language-ignore">while memory[ptr] != 0 {
    // Contents of loop
}
</code></pre>
</blockquote>
<p>Of course, we cannot <em>actually</em> emit an incomplete loop.  This <em>could</em> be solved by using <a href="../pat/README.html#push-down-accumulation">pushdown</a>, were it not for a more fundamental problem: we cannot <em>write</em> <code>while memory[ptr] != {</code>, at all, <em>anywhere</em>.  This is because doing so would introduce an unbalanced brace.</p>
<p>The solution to this is to actually split the input into two parts: everything <em>inside</em> the loop, and everything <em>after</em> it.  The <code>@x</code> rules handle the first, <code>@s</code> the latter.</p>
<pre><code class="language-ignore">    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook! Ook? $($tail:tt)*))
    =&gt; {
        while $a[$i] != 0 {
            Ook!(@x ($a, $i, $inc, $dec, $r, $w, $re); (); (); ($($tail)*));
        }
        Ook!(@s ($a, $i, $inc, $dec, $r, $w, $re); (); ($($tail)*));
    };
</code></pre>
<h3><a class="header" href="#loop-extraction" id="loop-extraction">Loop extraction</a></h3>
<p>Next are the <code>@x</code>, or &quot;extraction&quot;, rules.  These are responsible for taking an input tail and extracting the contents of a loop.  The general form of these rules is: <code>(@x $sym; $depth; $buf; $tail)</code>.</p>
<p>The purpose of <code>$sym</code> is the same as above.  <code>$tail</code> is the input to be parsed, whilst <code>$buf</code> is a <a href="../pat/README.html#push-down-accumulation">push-down accumulation buffer</a> into which we will collect the opcodes that are inside the loop.  But what of <code>$depth</code>?</p>
<p>A complication to all this is that loops can be <em>nested</em>.  Thus, we must have some way of keeping track of how many levels deep we currently are.  We must track this accurately enough to not stop parsing too early, nor too late, but when the level is <em>just right</em>.<sup class="footnote-reference"><a href="#justright">2</a></sup></p>
<div class="footnote-definition" id="justright"><sup class="footnote-definition-label">2</sup>
<pre><code>It is a little known fact[^fact] that the story of Goldie Locks was actually an allegory for accurate lexical parsing techniques.
</code></pre>
<div class="footnote-definition" id="fact"><sup class="footnote-definition-label">3</sup>
<p>And by &quot;fact&quot; I mean &quot;shameless fabrication&quot;.</p>
</div>
<p>Since we cannot do arithmetic in macros, and it would be infeasible to write out explicit integer-matching rules (imagine the following rules all copy &amp; pasted for a non-trivial number of positive integers), we will instead fall back on one of the most ancient and venerable counting methods in history: counting on our fingers.</p>
</div>
<p>But as macros don't <em>have</em> fingers, we'll use a <a href="../pat/README.html#abacus-counters">token abacus counter</a> instead.  Specifically, we will use <code>@</code>s, where each <code>@</code> represents one additional level of depth.  If we keep these <code>@</code>s contained in a group, we can implement the three important operations we need:</p>
<ul>
<li>Increment: match <code>($($depth:tt)*)</code>, substitute <code>(@ $($depth)*)</code>.</li>
<li>Decrement: match <code>(@ $($depth:tt)*)</code>, substitute <code>($($depth)*)</code>.</li>
<li>Compare to zero: match <code>()</code>.</li>
</ul>
<p>First is a rule to detect when we find the matching <code>Ook? Ook!</code> sequence that closes the loop we're parsing.  In this case, we feed the accumulated loop contents to the previously defined <code>@e</code> rules.</p>
<p>Note that we <em>do not</em> need to do anything with the remaining input tail (that will be handled by the <code>@s</code> rules).</p>
<pre><code class="language-ignore">    (@x $syms:tt; (); ($($buf:tt)*);
        (Ook? Ook! $($tail:tt)*))
    =&gt; {
        // Outer-most loop is closed.  Process the buffered tokens.
        Ook!(@e $syms; ($($buf)*));
    };
</code></pre>
<p>Next, we have rules for entering and exiting nested loops.  These adjust the counter and add the opcodes to the buffer.</p>
<pre><code class="language-ignore">    (@x $syms:tt; ($($depth:tt)*); ($($buf:tt)*);
        (Ook! Ook? $($tail:tt)*))
    =&gt; {
        // One level deeper.
        Ook!(@x $syms; (@ $($depth)*); ($($buf)* Ook! Ook?); ($($tail)*));
    };
    
    (@x $syms:tt; (@ $($depth:tt)*); ($($buf:tt)*);
        (Ook? Ook! $($tail:tt)*))
    =&gt; {
        // One level higher.
        Ook!(@x $syms; ($($depth)*); ($($buf)* Ook? Ook!); ($($tail)*));
    };
</code></pre>
<p>Finally, we have a rule for &quot;everything else&quot;.  Note the <code>$op0</code> and <code>$op1</code> captures: as far as Rust is concerned, our Ook! tokens are always <em>two</em> Rust tokens: the identifier <code>Ook</code>, and another token.  Thus, we can generalise over all non-loop opcodes by matching <code>!</code>, <code>?</code>, and <code>.</code> as <code>tt</code>s.</p>
<p>Here, we leave <code>$depth</code> untouched and just add the opcodes to the buffer.</p>
<pre><code class="language-ignore">    (@x $syms:tt; $depth:tt; ($($buf:tt)*);
        (Ook $op0:tt Ook $op1:tt $($tail:tt)*))
    =&gt; {
        Ook!(@x $syms; $depth; ($($buf)* Ook $op0 Ook $op1); ($($tail)*));
    };
</code></pre>
<h3><a class="header" href="#loop-skipping" id="loop-skipping">Loop Skipping</a></h3>
<p>This is <em>broadly</em> the same as loop extraction, except we don't care about the <em>contents</em> of the loop (and as such, don't need the accumulation buffer).  All we need to know is when we are <em>past</em> the loop.  At that point, we resume processing the input using the <code>@e</code> rules.</p>
<p>As such, these rules are presented without further exposition.</p>
<pre><code class="language-ignore">    // End of loop.
    (@s $syms:tt; ();
        (Ook? Ook! $($tail:tt)*))
    =&gt; {
        Ook!(@e $syms; ($($tail)*));
    };

    // Enter nested loop.
    (@s $syms:tt; ($($depth:tt)*);
        (Ook! Ook? $($tail:tt)*))
    =&gt; {
        Ook!(@s $syms; (@ $($depth)*); ($($tail)*));
    };
    
    // Exit nested loop.
    (@s $syms:tt; (@ $($depth:tt)*);
        (Ook? Ook! $($tail:tt)*))
    =&gt; {
        Ook!(@s $syms; ($($depth)*); ($($tail)*));
    };

    // Not a loop opcode.
    (@s $syms:tt; ($($depth:tt)*);
        (Ook $op0:tt Ook $op1:tt $($tail:tt)*))
    =&gt; {
        Ook!(@s $syms; ($($depth)*); ($($tail)*));
    };
</code></pre>
<h3><a class="header" href="#entry-point" id="entry-point">Entry point</a></h3>
<p>This is the only non-internal rule.</p>
<p>It is worth noting that because this formulation simply matches <em>all</em> tokens provided to it, it is <em>extremely dangerous</em>.  Any mistake can cause an invocation to fail to match all the above rules, thus falling down to this one and triggering an infinite recursion.</p>
<p>When you are writing, modifying, or debugging a macro like this, it is wise to temporarily prefix rules such as this one with something, such as <code>@entry</code>.  This prevents the infinite recursion case, and you are more likely to get matcher errors at the appropriate place.</p>
<pre><code class="language-ignore">    ($($Ooks:tt)*) =&gt; {
        Ook!(@start $($Ooks)*)
    };
}
</code></pre>
<h3><a class="header" href="#usage" id="usage">Usage</a></h3>
<p>Here, finally, is our test program.</p>
<pre><code class="language-ignore">fn main() {
    let _ = Ook!(
        Ook. Ook?  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook! Ook?  Ook? Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook?  Ook! Ook!  Ook? Ook!  Ook? Ook.
        Ook! Ook.  Ook. Ook?  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook! Ook?  Ook? Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook?
        Ook! Ook!  Ook? Ook!  Ook? Ook.  Ook. Ook.
        Ook! Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook! Ook.  Ook! Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook! Ook.  Ook. Ook?  Ook. Ook?
        Ook. Ook?  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook! Ook?  Ook? Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook?
        Ook! Ook!  Ook? Ook!  Ook? Ook.  Ook! Ook.
        Ook. Ook?  Ook. Ook?  Ook. Ook?  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook! Ook?  Ook? Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook?  Ook! Ook!  Ook? Ook!  Ook? Ook.
        Ook! Ook!  Ook! Ook!  Ook! Ook!  Ook! Ook.
        Ook? Ook.  Ook? Ook.  Ook? Ook.  Ook? Ook.
        Ook! Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook! Ook.  Ook! Ook!  Ook! Ook!  Ook! Ook!
        Ook! Ook!  Ook! Ook!  Ook! Ook!  Ook! Ook.
        Ook! Ook!  Ook! Ook!  Ook! Ook!  Ook! Ook!
        Ook! Ook!  Ook! Ook!  Ook! Ook!  Ook! Ook!
        Ook! Ook.  Ook. Ook?  Ook. Ook?  Ook. Ook.
        Ook! Ook.  Ook! Ook?  Ook! Ook!  Ook? Ook!
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook! Ook.
    );
}
</code></pre>
<p>The output when run (after a considerable pause for the compiler to do hundreds of recursive macro expansions) is:</p>
<pre><code class="language-text">Hello World!
</code></pre>
<p>With that, we have demonstrated the horrifying truth that <code>macro_rules!</code> is Turing-complete!</p>
<h3><a class="header" href="#an-aside" id="an-aside">An aside</a></h3>
<p>This was based on a macro implementing an isomorphic language called &quot;Hodor!&quot;.  Manish Goregaokar then <a href="https://www.reddit.com/r/rust/comments/39wvrm/hodor_esolang_as_a_rust_macro/cs76rqk?context=10000">implemented a Brainfuck interpreter using the Hodor! macro</a>.  So that is a Brainfuck interpreter written in Hodor! which was itself implemented using <code>macro_rules!</code>.</p>
<p>Legend has it that after raising the recursion limit to <em>three million</em> and allowing it to run for <em>four days</em>, it finally finished.</p>
<p>...by overflowing the stack and aborting.  To this day, esolang-as-macro remains a decidedly <em>non-viable</em> method of development with Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="aeg-README.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="aeg-README.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
